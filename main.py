import asyncio
import random
import logging
from datetime import datetime
from telethon import TelegramClient
import json

# –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ª–æ–≥—É–≤–∞–Ω–Ω—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('telegram_sender.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

class TelegramSender:
    def __init__(self, api_id, api_hash, phone_number):
        self.api_id = api_id
        self.api_hash = api_hash
        self.phone_number = phone_number
        self.client = TelegramClient('session', api_id, api_hash)
    
    async def load_groups(self, filename='groups.txt'):
        """–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Å–ø–∏—Å–∫—É –≥—Ä—É–ø –∑ —Ñ–∞–π–ª—É"""
        try:
            with open(filename, 'r', encoding='utf-8') as file:
                groups = [line.strip() for line in file if line.strip()]
            logger.info(f"–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ {len(groups)} –≥—Ä—É–ø –∑ —Ñ–∞–π–ª—É {filename}")
            return groups
        except FileNotFoundError:
            logger.error(f"–§–∞–π–ª {filename} –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ!")
            return []
        except Exception as e:
            logger.error(f"–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ –≥—Ä—É–ø: {e}")
            return []
    
    def load_messages(self, filename='messages.txt'):
        """–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Å–ø–∏—Å–∫—É –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å –∑ —Ñ–∞–π–ª—É"""
        try:
            with open(filename, 'r', encoding='utf-8') as file:
                content = file.read()
                # –†–æ–∑–¥—ñ–ª—è—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø–æ–¥–≤—ñ–π–Ω–∏–º –ø–µ—Ä–µ—Ö–æ–¥–æ–º –Ω–∞ –Ω–æ–≤–∏–π —Ä—è–¥–æ–∫
                messages = [msg.strip() for msg in content.split('\n\n') if msg.strip()]
            logger.info(f"–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ {len(messages)} –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å –∑ —Ñ–∞–π–ª—É {filename}")
            return messages
        except FileNotFoundError:
            logger.error(f"–§–∞–π–ª {filename} –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ!")
            return []
        except Exception as e:
            logger.error(f"–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å: {e}")
            return []
    
    def get_random_delay(self):
        """–ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –≤–∏–ø–∞–¥–∫–æ–≤–æ—ó –∑–∞—Ç—Ä–∏–º–∫–∏ –≤—ñ–¥ 40 –¥–æ 90 —Ö–≤–∏–ª–∏–Ω"""
        delay_minutes = random.randint(40, 90)
        delay_seconds = delay_minutes * 60
        logger.info(f"–ù–∞—Å—Ç—É–ø–Ω–∞ –∑–∞—Ç—Ä–∏–º–∫–∞: {delay_minutes} —Ö–≤–∏–ª–∏–Ω ({delay_seconds} —Å–µ–∫—É–Ω–¥)")
        return delay_seconds
    
    def extract_group_identifier(self, group_link):
        """–í–∏—Ç—è–≥—É—î —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä –≥—Ä—É–ø–∏ –∑ –ø–æ—Å–∏–ª–∞–Ω–Ω—è"""
        if group_link.startswith('https://t.me/'):
            # –í–∏—Ç—è–≥—É—î–º–æ username –∑ –ø–æ—Å–∏–ª–∞–Ω–Ω—è
            return group_link.replace('https://t.me/', '').split('?')[0]
        elif group_link.startswith('@'):
            # –Ø–∫—â–æ –≤–∂–µ —î username
            return group_link
        else:
            # –Ø–∫—â–æ —Ü–µ –ø—Ä–æ—Å—Ç–æ –Ω–∞–∑–≤–∞ –∞–±–æ username –±–µ–∑ @
            return group_link
    
    async def send_message_to_group(self, group_link, message):
        """–ù–∞–¥—Å–∏–ª–∞–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É –≥—Ä—É–ø—É"""
        try:
            # –í–∏—Ç—è–≥—É—î–º–æ —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä –≥—Ä—É–ø–∏ –∑ –ø–æ—Å–∏–ª–∞–Ω–Ω—è
            group_identifier = self.extract_group_identifier(group_link)
            
            # –°–ø—Ä–æ–±–∞ –∑–Ω–∞–π—Ç–∏ –≥—Ä—É–ø—É
            entity = await self.client.get_entity(group_identifier)
            await self.client.send_message(entity, message)
            logger.info(f"‚úÖ –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è —É—Å–ø—ñ—à–Ω–æ –Ω–∞–¥—ñ—Å–ª–∞–Ω–æ –≤ –≥—Ä—É–ø—É: {group_link}")
            return True
        except Exception as e:
            logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –Ω–∞–¥—Å–∏–ª–∞–Ω–Ω—ñ –≤ –≥—Ä—É–ø—É {group_link}: {e}")
            return False
    
    async def start_mass_sending(self):
        """–û—Å–Ω–æ–≤–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –¥–ª—è –º–∞—Å–æ–≤–æ—ó —Ä–æ–∑—Å–∏–ª–∫–∏"""
        try:
            # –ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ Telegram
            await self.client.start(phone=self.phone_number)
            logger.info("‚úÖ –£—Å–ø—ñ—à–Ω–æ –ø—ñ–¥–∫–ª—é—á–µ–Ω–æ –¥–æ Telegram")
            
            # –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –≥—Ä—É–ø —ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å
            groups = await self.load_groups()
            messages = self.load_messages()
            
            if not groups:
                logger.error("–°–ø–∏—Å–æ–∫ –≥—Ä—É–ø –ø–æ—Ä–æ–∂–Ω—ñ–π!")
                return
            
            if not messages:
                logger.error("–°–ø–∏—Å–æ–∫ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å –ø–æ—Ä–æ–∂–Ω—ñ–π!")
                return
            
            logger.info(f"–ü–æ—á–∞—Ç–æ–∫ —Ä–æ–∑—Å–∏–ª–∫–∏ –≤ {len(groups)} –≥—Ä—É–ø")
            
            successful_sends = 0
            failed_sends = 0
            
            for i, group_link in enumerate(groups, 1):
                # –í–∏–±—ñ—Ä –≤–∏–ø–∞–¥–∫–æ–≤–æ–≥–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
                random_message = random.choice(messages)
                
                logger.info(f"[{i}/{len(groups)}] –ù–∞–¥—Å–∏–ª–∞–Ω–Ω—è –≤ –≥—Ä—É–ø—É: {group_link}")
                logger.info(f"–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: {random_message[:50]}...")
                
                # –ù–∞–¥—Å–∏–ª–∞–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
                success = await self.send_message_to_group(group_link, random_message)
                
                if success:
                    successful_sends += 1
                else:
                    failed_sends += 1
                
                # –ó–∞—Ç—Ä–∏–º–∫–∞ –ø–µ—Ä–µ–¥ –Ω–∞—Å—Ç—É–ø–Ω–∏–º –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º (–æ–∫—Ä—ñ–º –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ)
                if i < len(groups):
                    delay = self.get_random_delay()
                    logger.info(f"‚è≥ –û—á—ñ–∫—É–≤–∞–Ω–Ω—è {delay//60} —Ö–≤–∏–ª–∏–Ω –ø–µ—Ä–µ–¥ –Ω–∞—Å—Ç—É–ø–Ω–∏–º –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º...")
                    await asyncio.sleep(delay)
            
            # –ü—ñ–¥—Å—É–º–∫–æ–≤–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
            logger.info("="*50)
            logger.info("üìä –ü–Ü–î–°–£–ú–ö–û–í–ê –°–¢–ê–¢–ò–°–¢–ò–ö–ê:")
            logger.info(f"‚úÖ –£—Å–ø—ñ—à–Ω–æ –Ω–∞–¥—ñ—Å–ª–∞–Ω–æ: {successful_sends}")
            logger.info(f"‚ùå –ü–æ–º–∏–ª–æ–∫: {failed_sends}")
            logger.info(f"üìù –í—Å—å–æ–≥–æ –≥—Ä—É–ø: {len(groups)}")
            logger.info("="*50)
            
        except Exception as e:
            logger.error(f"–ö—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞: {e}")
        finally:
            await self.client.disconnect()

async def main():
    # –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è Telegram API
    # –û—Ç—Ä–∏–º–∞—Ç–∏ —Ü—ñ –¥–∞–Ω—ñ –º–æ–∂–Ω–∞ –Ω–∞ https://my.telegram.org/apps
    API_ID = '26812497'  # –ó–∞–º—ñ–Ω—ñ—Ç—å –Ω–∞ –≤–∞—à API ID
    API_HASH = '76638ee0a131af4fdf1a388f0b947b78'  # –ó–∞–º—ñ–Ω—ñ—Ç—å –Ω–∞ –≤–∞—à API Hash
    PHONE_NUMBER = '+380631420477'  # –ó–∞–º—ñ–Ω—ñ—Ç—å –Ω–∞ –≤–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É (+380XXXXXXXXX)
    
    if API_ID == 'YOUR_API_ID' or API_HASH == 'YOUR_API_HASH':
        print("‚ùå –ë—É–¥—å –ª–∞—Å–∫–∞, –≤–∫–∞–∂—ñ—Ç—å –≤–∞—à—ñ –¥–∞–Ω—ñ API –≤ –∫–æ–¥—ñ!")
        print("–û—Ç—Ä–∏–º–∞—Ç–∏ —ó—Ö –º–æ–∂–Ω–∞ –Ω–∞ https://my.telegram.org/apps")
        return
    
    sender = TelegramSender(API_ID, API_HASH, PHONE_NUMBER)
    await sender.start_mass_sending()

if __name__ == "__main__":
    asyncio.run(main())