import asyncio
import random
import logging
from datetime import datetime, timedelta
from telethon import TelegramClient
from config import API_ID, API_HASH, PHONE_NUMBER
import json

# –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ª–æ–≥—É–≤–∞–Ω–Ω—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('telegram_sender.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

class TelegramSender:
    def __init__(self, api_id, api_hash, phone_number):
        self.api_id = api_id
        self.api_hash = api_hash
        self.phone_number = phone_number
        self.client = TelegramClient('session', api_id, api_hash)
    
    async def load_groups(self, filename='groups.txt'):
        """–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Å–ø–∏—Å–∫—É –≥—Ä—É–ø –∑ —Ñ–∞–π–ª—É"""
        try:
            with open(filename, 'r', encoding='utf-8') as file:
                groups = [line.strip() for line in file if line.strip()]
            logger.info(f"–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ {len(groups)} –≥—Ä—É–ø –∑ —Ñ–∞–π–ª—É {filename}")
            return groups
        except FileNotFoundError:
            logger.error(f"–§–∞–π–ª {filename} –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ!")
            return []
        except Exception as e:
            logger.error(f"–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ –≥—Ä—É–ø: {e}")
            return []
    
    def load_messages(self, filename='messages.txt'):
        """–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Å–ø–∏—Å–∫—É –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å –∑ —Ñ–∞–π–ª—É"""
        try:
            with open(filename, 'r', encoding='utf-8') as file:
                content = file.read()
                # –†–æ–∑–¥—ñ–ª—è—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø–æ–¥–≤—ñ–π–Ω–∏–º –ø–µ—Ä–µ—Ö–æ–¥–æ–º –Ω–∞ –Ω–æ–≤–∏–π —Ä—è–¥–æ–∫
                messages = [msg.strip() for msg in content.split('\n\n') if msg.strip()]
            logger.info(f"–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ {len(messages)} –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å –∑ —Ñ–∞–π–ª—É {filename}")
            return messages
        except FileNotFoundError:
            logger.error(f"–§–∞–π–ª {filename} –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ!")
            return []
        except Exception as e:
            logger.error(f"–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å: {e}")
            return []
    
    def get_random_delay(self):
        """–ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –≤–∏–ø–∞–¥–∫–æ–≤–æ—ó –∑–∞—Ç—Ä–∏–º–∫–∏ –≤—ñ–¥ 40 –¥–æ 90 —Ö–≤–∏–ª–∏–Ω"""
        delay_minutes = random.randint(40, 90)
        delay_seconds = delay_minutes * 60
        logger.info(f"–ù–∞—Å—Ç—É–ø–Ω–∞ –∑–∞—Ç—Ä–∏–º–∫–∞: {delay_minutes} —Ö–≤–∏–ª–∏–Ω ({delay_seconds} —Å–µ–∫—É–Ω–¥)")
        return delay_seconds
    
    def extract_group_identifier(self, group_link):
        """–í–∏—Ç—è–≥—É—î —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä –≥—Ä—É–ø–∏ –∑ –ø–æ—Å–∏–ª–∞–Ω–Ω—è"""
        if group_link.startswith('https://t.me/'):
            # –í–∏—Ç—è–≥—É—î–º–æ username –∑ –ø–æ—Å–∏–ª–∞–Ω–Ω—è
            return group_link.replace('https://t.me/', '').split('?')[0]
        elif group_link.startswith('@'):
            # –Ø–∫—â–æ –≤–∂–µ —î username
            return group_link
        else:
            # –Ø–∫—â–æ —Ü–µ –ø—Ä–æ—Å—Ç–æ –Ω–∞–∑–≤–∞ –∞–±–æ username –±–µ–∑ @
            return group_link
    
    async def send_message_to_group(self, group_link, message):
        """–ù–∞–¥—Å–∏–ª–∞–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É –≥—Ä—É–ø—É"""
        try:
            # –í–∏—Ç—è–≥—É—î–º–æ —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä –≥—Ä—É–ø–∏ –∑ –ø–æ—Å–∏–ª–∞–Ω–Ω—è
            group_identifier = self.extract_group_identifier(group_link)
            
            # –°–ø—Ä–æ–±–∞ –∑–Ω–∞–π—Ç–∏ –≥—Ä—É–ø—É
            entity = await self.client.get_entity(group_identifier)
            await self.client.send_message(entity, message)
            logger.info(f"‚úÖ –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è —É—Å–ø—ñ—à–Ω–æ –Ω–∞–¥—ñ—Å–ª–∞–Ω–æ –≤ –≥—Ä—É–ø—É: {group_link}")
            return True
        except Exception as e:
            logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –Ω–∞–¥—Å–∏–ª–∞–Ω–Ω—ñ –≤ –≥—Ä—É–ø—É {group_link}: {e}")
            return False
    
    async def start_mass_sending(self, cycles=1):
        """–û—Å–Ω–æ–≤–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –¥–ª—è –º–∞—Å–æ–≤–æ—ó —Ä–æ–∑—Å–∏–ª–∫–∏"""
        try:
            # –ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ Telegram
            await self.client.start(phone=self.phone_number)
            logger.info("‚úÖ –£—Å–ø—ñ—à–Ω–æ –ø—ñ–¥–∫–ª—é—á–µ–Ω–æ –¥–æ Telegram")
            
            # –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –≥—Ä—É–ø —ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å
            groups = await self.load_groups()
            messages = self.load_messages()
            
            if not groups:
                logger.error("–°–ø–∏—Å–æ–∫ –≥—Ä—É–ø –ø–æ—Ä–æ–∂–Ω—ñ–π!")
                return
            
            if not messages:
                logger.error("–°–ø–∏—Å–æ–∫ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å –ø–æ—Ä–æ–∂–Ω—ñ–π!")
                return
            
            # –í–∏–∑–Ω–∞—á–µ–Ω–Ω—è —Ä–µ–∂–∏–º—É —Ä–æ–±–æ—Ç–∏
            infinite_mode = cycles == 999
            if infinite_mode:
                logger.info(f"üîÑ –ü–æ—á–∞—Ç–æ–∫ –ë–ï–ó–ö–Ü–ù–ï–ß–ù–û–á —Ä–æ–∑—Å–∏–ª–∫–∏ –≤ {len(groups)} –≥—Ä—É–ø")
                logger.info("‚ö†Ô∏è –î–ª—è –∑—É–ø–∏–Ω–∫–∏ –Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å Ctrl+C")
            else:
                logger.info(f"üîÑ –ü–æ—á–∞—Ç–æ–∫ —Ä–æ–∑—Å–∏–ª–∫–∏ –≤ {len(groups)} –≥—Ä—É–ø, —Ü–∏–∫–ª—ñ–≤: {cycles}")
            
            total_successful = 0
            total_failed = 0
            current_cycle = 0
            
            try:
                while True:
                    current_cycle += 1
                    
                    # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —á–∏ –Ω–µ –¥–æ—Å—è–≥–Ω—É—Ç–æ –ª—ñ–º—ñ—Ç —Ü–∏–∫–ª—ñ–≤ (—Ç—ñ–ª—å–∫–∏ –¥–ª—è —Å–∫—ñ–Ω—á–µ–Ω–Ω–æ–≥–æ —Ä–µ–∂–∏–º—É)
                    if not infinite_mode and current_cycle > cycles:
                        break
                    
                    logger.info("="*60)
                    if infinite_mode:
                        logger.info(f"üîÑ –¶–ò–ö–õ {current_cycle} (–ë–ï–ó–ö–Ü–ù–ï–ß–ù–ò–ô –†–ï–ñ–ò–ú)")
                    else:
                        logger.info(f"üîÑ –¶–ò–ö–õ {current_cycle}/{cycles}")
                    logger.info("="*60)
                    
                    cycle_successful = 0
                    cycle_failed = 0
                    
                    for i, group_link in enumerate(groups, 1):
                        # –í–∏–±—ñ—Ä –≤–∏–ø–∞–¥–∫–æ–≤–æ–≥–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –¥–ª—è –∫–æ–∂–Ω–æ—ó –≥—Ä—É–ø–∏
                        random_message = random.choice(messages)
                        
                        logger.info(f"[{i}/{len(groups)}] –ù–∞–¥—Å–∏–ª–∞–Ω–Ω—è –≤ –≥—Ä—É–ø—É: {group_link}")
                        logger.info(f"–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: {random_message[:50]}...")
                        
                        # –ù–∞–¥—Å–∏–ª–∞–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
                        success = await self.send_message_to_group(group_link, random_message)
                        
                        if success:
                            cycle_successful += 1
                            total_successful += 1
                        else:
                            cycle_failed += 1
                            total_failed += 1
                        
                        # –ù–µ–≤–µ–ª–∏–∫–∞ –∑–∞—Ç—Ä–∏–º–∫–∞ –º—ñ–∂ –≥—Ä—É–ø–∞–º–∏ –≤ –º–µ–∂–∞—Ö –æ–¥–Ω–æ–≥–æ —Ü–∏–∫–ª—É (—â–æ–± –Ω–µ –∑–∞–±–ª–æ–∫—É–≤–∞–ª–∏)
                        if i < len(groups):
                            small_delay = random.randint(5, 15)  # 5-15 —Å–µ–∫—É–Ω–¥ –º—ñ–∂ –≥—Ä—É–ø–∞–º–∏
                            logger.info(f"‚è≥ –ú–∞–ª–∞ –∑–∞—Ç—Ä–∏–º–∫–∞: {small_delay} —Å–µ–∫—É–Ω–¥...")
                            await asyncio.sleep(small_delay)
                    
                    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ü–∏–∫–ª—É
                    logger.info("-"*50)
                    if infinite_mode:
                        logger.info(f"üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê –¶–ò–ö–õ–£ {current_cycle} (–ë–ï–ó–ö–Ü–ù–ï–ß–ù–ò–ô):")
                    else:
                        logger.info(f"üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê –¶–ò–ö–õ–£ {current_cycle}/{cycles}:")
                    logger.info(f"‚úÖ –£—Å–ø—ñ—à–Ω–æ –Ω–∞–¥—ñ—Å–ª–∞–Ω–æ: {cycle_successful}")
                    logger.info(f"‚ùå –ü–æ–º–∏–ª–æ–∫: {cycle_failed}")
                    logger.info(f"üìù –í—Å—å–æ–≥–æ –≥—Ä—É–ø –≤ —Ü–∏–∫–ª—ñ: {len(groups)}")
                    logger.info(f"üìà –ó–∞–≥–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: ‚úÖ{total_successful} ‚ùå{total_failed}")
                    logger.info("-"*50)
                    
                    # –í–µ–ª–∏–∫–∞ –∑–∞—Ç—Ä–∏–º–∫–∞ –ø—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è —Ü–∏–∫–ª—É
                    # (–¥–ª—è –±–µ–∑–∫—ñ–Ω–µ—á–Ω–æ–≥–æ —Ä–µ–∂–∏–º—É –∑–∞–≤–∂–¥–∏, –¥–ª—è —Å–∫—ñ–Ω—á–µ–Ω–Ω–æ–≥–æ - –æ–∫—Ä—ñ–º –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ)
                    if infinite_mode or current_cycle < cycles:
                        delay = self.get_random_delay()
                        next_time = (datetime.now() + timedelta(seconds=delay)).strftime('%H:%M:%S %d.%m.%Y')
                        
                        if infinite_mode:
                            logger.info(f"üïê –ó–ê–¢–†–ò–ú–ö–ê –ú–Ü–ñ –¶–ò–ö–õ–ê–ú–ò: {delay//60} —Ö–≤–∏–ª–∏–Ω ({delay} —Å–µ–∫—É–Ω–¥)")
                            logger.info(f"‚è∞ –ù–∞—Å—Ç—É–ø–Ω–∏–π —Ü–∏–∫–ª {current_cycle + 1} –ø–æ—á–Ω–µ—Ç—å—Å—è –æ {next_time}")
                        else:
                            logger.info(f"üïê –ó–ê–¢–†–ò–ú–ö–ê –ú–Ü–ñ –¶–ò–ö–õ–ê–ú–ò: {delay//60} —Ö–≤–∏–ª–∏–Ω ({delay} —Å–µ–∫—É–Ω–¥)")
                            logger.info(f"‚è∞ –ù–∞—Å—Ç—É–ø–Ω–∏–π —Ü–∏–∫–ª {current_cycle + 1}/{cycles} –ø–æ—á–Ω–µ—Ç—å—Å—è –æ {next_time}")
                        
                        await asyncio.sleep(delay)
                        
            except KeyboardInterrupt:
                logger.info("\n" + "="*60)
                logger.info("‚ö†Ô∏è –û–¢–†–ò–ú–ê–ù–û –°–ò–ì–ù–ê–õ –ó–£–ü–ò–ù–ö–ò (Ctrl+C)")
                logger.info("üõë –ó—É–ø–∏–Ω–∫–∞ —Ä–æ–∑—Å–∏–ª–∫–∏...")
                logger.info("="*60)
            
            # –ü—ñ–¥—Å—É–º–∫–æ–≤–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –≤—Å—ñ—Ö —Ü–∏–∫–ª—ñ–≤
            logger.info("="*60)
            logger.info("üèÅ –ü–Ü–î–°–£–ú–ö–û–í–ê –°–¢–ê–¢–ò–°–¢–ò–ö–ê:")
            logger.info(f"‚úÖ –í—Å—å–æ–≥–æ —É—Å–ø—ñ—à–Ω–æ –Ω–∞–¥—ñ—Å–ª–∞–Ω–æ: {total_successful}")
            logger.info(f"‚ùå –í—Å—å–æ–≥–æ –ø–æ–º–∏–ª–æ–∫: {total_failed}")
            logger.info(f"üîÑ –¶–∏–∫–ª—ñ–≤ –≤–∏–∫–æ–Ω–∞–Ω–æ: {current_cycle}")
            logger.info(f"üìù –ì—Ä—É–ø –≤ –∫–æ–∂–Ω–æ–º—É —Ü–∏–∫–ª—ñ: {len(groups)}")
            logger.info(f"üìä –í—Å—å–æ–≥–æ —Å–ø—Ä–æ–± –≤—ñ–¥–ø—Ä–∞–≤–∫–∏: {current_cycle * len(groups)}")
            if infinite_mode:
                logger.info("‚ôæÔ∏è –†–µ–∂–∏–º: –ë–ï–ó–ö–Ü–ù–ï–ß–ù–ò–ô (–∑—É–ø–∏–Ω–µ–Ω–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–µ–º)")
            else:
                logger.info(f"üéØ –†–µ–∂–∏–º: –°–ö–Ü–ù–ß–ï–ù–ù–ò–ô ({cycles} —Ü–∏–∫–ª—ñ–≤)")
            logger.info("="*60)
            
        except Exception as e:
            logger.error(f"–ö—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞: {e}")
        finally:
            await self.client.disconnect()

def get_cycles_from_user():
    """–û—Ç—Ä–∏–º–∞–Ω–Ω—è –∫—ñ–ª—å–∫–æ—Å—Ç—ñ —Ü–∏–∫–ª—ñ–≤ –≤—ñ–¥ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞"""
    while True:
        try:
            print("\n" + "="*50)
            print("üîÑ –ù–ê–õ–ê–®–¢–£–í–ê–ù–ù–Ø –¶–ò–ö–õ–Ü–í –†–û–ó–°–ò–õ–ö–ò")
            print("="*50)
            print("1Ô∏è‚É£  –í–≤–µ–¥—ñ—Ç—å —á–∏—Å–ª–æ –≤—ñ–¥ 1 –¥–æ 998 - –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Ü–∏–∫–ª—ñ–≤")
            print("‚ôæÔ∏è  –í–≤–µ–¥—ñ—Ç—å 999 - –¥–ª—è –±–µ–∑–∫—ñ–Ω–µ—á–Ω–æ—ó —Ä–æ–∑—Å–∏–ª–∫–∏")
            print("‚ùå –í–≤–µ–¥—ñ—Ç—å 0 - –¥–ª—è –≤–∏—Ö–æ–¥—É")
            print("-"*50)
            
            user_input = input("–í–≤–µ–¥—ñ—Ç—å –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Ü–∏–∫–ª—ñ–≤: ").strip()
            
            if not user_input:
                print("‚ùå –ü–æ—Ä–æ–∂–Ω—ñ–π –≤–≤—ñ–¥! –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑.")
                continue
            
            cycles = int(user_input)
            
            if cycles == 0:
                print("üëã –í–∏—Ö—ñ–¥ –∑ –ø—Ä–æ–≥—Ä–∞–º–∏...")
                return None
            elif cycles == 999:
                print("‚ôæÔ∏è –û–±—Ä–∞–Ω–æ –ë–ï–ó–ö–Ü–ù–ï–ß–ù–ò–ô —Ä–µ–∂–∏–º —Ä–æ–∑—Å–∏–ª–∫–∏!")
                print("‚ö†Ô∏è –î–ª—è –∑—É–ø–∏–Ω–∫–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ Ctrl+C")
                confirm = input("–ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏? (y/n): ").strip().lower()
                if confirm in ['y', 'yes', '—Ç–∞–∫', '—Ç']:
                    return 999
                else:
                    continue
            elif 1 <= cycles <= 998:
                print(f"‚úÖ –û–±—Ä–∞–Ω–æ {cycles} —Ü–∏–∫–ª—ñ–≤ —Ä–æ–∑—Å–∏–ª–∫–∏")
                return cycles
            else:
                print("‚ùå –ù–µ–∫–æ—Ä–µ–∫—Ç–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è! –í–≤–µ–¥—ñ—Ç—å —á–∏—Å–ª–æ –≤—ñ–¥ 1 –¥–æ 998, –∞–±–æ 999 –¥–ª—è –±–µ–∑–∫—ñ–Ω–µ—á–Ω–æ—ó —Ä–æ–∑—Å–∏–ª–∫–∏.")
                continue
                
        except ValueError:
            print("‚ùå –ù–µ–∫–æ—Ä–µ–∫—Ç–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç! –í–≤–µ–¥—ñ—Ç—å —á–∏—Å–ª–æ.")
        except KeyboardInterrupt:
            print("\nüëã –í–∏—Ö—ñ–¥ –∑ –ø—Ä–æ–≥—Ä–∞–º–∏...")
            return None

async def main():
    # –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è Telegram API –≤–∑—è—Ç–æ –∑ config.py
    # –û—Ç—Ä–∏–º–∞—Ç–∏ —Ü—ñ –¥–∞–Ω—ñ –º–æ–∂–Ω–∞ –Ω–∞ https://my.telegram.org/apps
    # –¢–µ–ø–µ—Ä –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —ñ–º–ø–æ—Ä—Ç–æ–≤–∞–Ω—ñ –∑–º—ñ–Ω–Ω—ñ
    print(f"API_ID: {API_ID}")
    print(f"API_HASH: {API_HASH}")
    print(f"PHONE_NUMBER: {PHONE_NUMBER}")
    
    if API_ID == 'YOUR_API_ID' or API_HASH == 'YOUR_API_HASH':
        print("‚ùå –ë—É–¥—å –ª–∞—Å–∫–∞, –≤–∫–∞–∂—ñ—Ç—å –≤–∞—à—ñ –¥–∞–Ω—ñ API –≤ –∫–æ–¥—ñ!")
        print("–û—Ç—Ä–∏–º–∞—Ç–∏ —ó—Ö –º–æ–∂–Ω–∞ –Ω–∞ https://my.telegram.org/apps")
        return
    
    # –û—Ç—Ä–∏–º–∞–Ω–Ω—è –∫—ñ–ª—å–∫–æ—Å—Ç—ñ —Ü–∏–∫–ª—ñ–≤ –≤—ñ–¥ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
    cycles = get_cycles_from_user()
    if cycles is None:
        return
    
    print("\nüöÄ –ü–æ—á–∞—Ç–æ–∫ —Ä–æ–±–æ—Ç–∏ Telegram Sender...")
    sender = TelegramSender(API_ID, API_HASH, PHONE_NUMBER)
    await sender.start_mass_sending(cycles=cycles)

if __name__ == "__main__":
    asyncio.run(main())